

# Names and Values

## Copies and Assignment
https://adv-r.hadley.nz/names-values.html

```{r}
library(lobstr)
library(tidyverse)

```

An assignment does not "create" an object. It assoicates a memory address with a value. Multiple names can be bound to the same _single_ value; no copies are made when this is done. In all but two cases (see below), the original memory address is retained, with copies being made as necessary. Lobstr confirms this.
```{r}

x <- c(1,2,3)
tracemem(x)
y <- x
y <- y*2
x

obj_addr(x)
obj_addr(y)
```
Here are 4 references to the same value - except d, since the : function is doing something odd. Note mapping changes the addresses
```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)

map(list(a, b,c,d), obj_addr)

```

```{r}
obj_addr(mean)
obj_addr(base::mean)
obj_addr(evalq(mean))
```
R copies on modify. Here, R creates a copy of x's object,changed the third element, then bound y to that object. _The original object was not changed_. With some exceptions, R objects are generally immutable. 
The copies are made when the binding symbol <- is invoked. Again, _no copy is made when a new name is bound to an existing value_.
```{r}

x <- c(1, 2, 3)
tracemem(x)
y <- x

y[[3]] <- 4
x
#> [1] 1 2 3
```

Tracemem, once called, informs you when a copy is made and what adrress recives it. Note that subsequent modifications  don't get messages because the new object is only bound to y.

Here, two copies are made, because y is modified twice.

```{r}
x <- c(1, 2, 3)
cat(tracemem(x), "\n")
y <- x
y[[3]] <- 4
y[[3]] <- 3
```

This works about the same with functions. No copying takes place here because a (in f's execution environment) and x point to the same object.
```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")
#> <0x7fc8257ebae8>

z <- f(x)

```
Contrast a modification:

```{r}
f <- function(a) {
  a[[3]] <- 2
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")
#> <0x7fc8257ebae8>

z <- f(x)

```

## Lists 

Lists do not store values but _references_ to values. Lists are copied shallowly: the list object and its bindings (here just indices, otherwise names) are copied, but the _values_ pointed to by list bindings are not (i.e., are pointed to by both lists). If just one element is modified, the others are shared across the two lists. Contrst this with vectors, which create entire copies if a single element is changed. Notice here how lements 1 and 2 are shared after copying but not elment 3 (the one modified).

```{r}
l <- list(1,2,3)
tracemem(l)
l2 <- l
l2[[3]] <- 4

ref(l, l2)
```
This is advantageous when working with dataframes, which are really lists. Modifying a single column only changes that column's value; the other column names point to the same values.

```{r}
d1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))
d2 <- d1
d2[, 2] <- d2[, 2] * 2

ref(d1, d2)
```
Modifying a row changes every column (i.e., element), requiring more copying. No addresses are now shared.

```{r}
d3 <- d1
d3[1, ] <- d3[1, ] * 3
ref(d3, d1)
```

Character vectors are a special case. Each element actually points to a unique string in a global pool. This saves a lot of storage space if elements are repeated.

```{r}
ref(rep(letters, 2), character = TRUE)

f <- function(){
  x <-  5
g(x)
}
g <- function(x = x){
  test <- expr(x)
  x <-  7
  
  eval(test, enclos = parent.frame())
}
f()
```

In the sneaky second example, note how two copies are made because x is coerced from numeric to int.
```{r}
x <- c(1:10)
cat(tracemem(x), "\n")
y <- x

x <- c(1L, 2L, 3L)
tracemem(x)

x[[3]] <- 4
```
In this complex example, the second and third elements of c point to 1:10, while the first is a list pointing to that same value.

```{r}
a <- 1:10
tracemem(a)
b <- list(a, a)
c <- list(b, a, 1:10)

ref(a,b,c[[1]])
```
Once again, the nested list points to the same value as does the first element of the outer list.
```{r}
x <- list(1:10)
tracemem(x)
x[[2]] <- x
ref(x[1], x[[2]])
```
### Object Sizes

Lobstr's obj_size tells you the size of objects. Lists are surprisingly small, since multiple names can be bound to the same value.

Here, y is only bigger by the three list objects needed to contain x (remember, a single value with multiple mappings). Character vectors are similar due to multiples tring pools
```{r}
x <- runif(1e6)
obj_size(x)
#> 8,000,048 B

y <- list(x, x, x)
obj_size(y)
#> 8,000,128 B
```

Adding object sizes is therefore distirbutive (obj_size(x) + obj_size(y) = obj_size(x, y)) only when no values are shared. Otherwise, the shared values 

```{r}
obj_size(1:3)
#> 680 B
obj_size(1:1e3)
#> 680 B
obj_size(1:1e6)
#> 680 B
obj_size(1:1e9)
#> 680 B
```

This list is a little smaller than the separate functions 
```{r}
funs <- list(mean, sd, var)
obj_size(funs)
#> 17,608 B
#
obj_size(mean) +obj_size(sd) +obj_size(var)
```

In the first example here, b added to a had the same size as b becasue a is a subset of a - b already contains every value in a.

Watch out in the second example. 
```{r}
a <- runif(1e6)
obj_size(a)

b <- list(a, a)
obj_size(b)
obj_size(a, b)
cat("\n")

b[[1]][[1]] <- 10
obj_size(b)
obj_size(a, b)

b[[2]][[1]] <- 10
obj_size(b)
obj_size(a, b)
```

## Modify In-Place

There are only two cases of in-place modification (i.e, the value at the memory address being cahnged, not a copy created and modified): objects bound to a single name, and environments.

The first case is an optimization. Almost all functions also refer to objects, not memory addresses (since args are passed by value). Only primitives refer directly to addresses.

```{r}
v <- c(1,2,3)
tracemem(v)
v[[3]] <- 4
```

Take this example. the loop takes awhile because each iteration shallowly copies the whole dataframe three times - once each to subset x and medians, and a third time because [[data.frame, being a non-primitive, has to be passed a copu a copy.
```{r}

x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
cat(tracemem(x), "\n")
medians <- vapply(x, median, numeric(1))

for (i in seq_along(medians)) {
  x[[i]] <- x[[i]] - medians[[i]]
}
```

Lists, which use C code, do not have this problem:

```{r}
y <- as.list(x)
cat(tracemem(y), "\n")
#> <0x7f80c5c3de20>
  
for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}
#> tracemem[0x7f80c5c3de20 -> 0x7f80c48de210]: 
```

## Modifying Environments

Environments are also modified in-place. This is useful because it preserves the references of all bindings within the environment, which would otherwise change if a copy were made. This is why deep assignments are preserved after function calls end: they bind a name in the enclosing environment, for a manufactured function the function that defines it. The assignment persists.
```{r}
e1 <- rlang::env(a = 1, b = 2, c = 3)

e2 <- e1
e1$c <- 4
e2$c

```

It is possible for environemnts to contain themselves!

```{r}
e <- rlang::env()
e$self <- e

ref(e)

x <- list()
x[[1]] <- x
```

```{r}

# w <- c("am", "I", "global")
# rev(w)
# function(x) UseMethod("rev")(c("am", "I", "global"))
# 
# tab <- tibble(key = union(mtcars$vs, mtcars$carb)) %>% 
#   arrange(key) %>% 
#   left_join(mutate(as.data.frame(table(mtcars$vs)), Var1 = as.numeric(Var1)), by = c("key"="Var1")) %>% 
#   left_join(mutate(as.data.frame(table(mtcars$carb)), Var1 = as.numeric(Var1)),c("key"="Var1")) 
# 
# tab[is.na(tab)] <- 0
# tab <- do.call(rbind, tab)
```

## Case Study: Environment Manipulation

I define an environment and give it a name:
```{r}
e <- new.env()
parent.env(e)
parent.env(globalenv())

attr(e, "name") <- "example"
e
```
2 ways to assign to an environment. You can use get to retrieve value.
```{r}
ls(envir = environment())

e$test <- "test"
assign("test2", envir = e, "b")
map(ls(envir = e), get, envir = e)
```
Assign parents manually.
```{r}
e2 <- new.env()
parent.env(e2) <- e

parent.env(e2)
```

Illustrating lexical scoping, Test is enclosed by the global environment.
```{r}
 Test = function() { print( parent.env( environment() ) ) }
> Test()
```
```{r}

```

Function enclosures can be respecified, if you really want to:
```{r}
```

Here MyFunction finds x in its manually set enclosure and y in its enclsoure, the global environment.
```{r}
x <- 5
y <- 6
MyFunction = function() {
  print(x) 
  print(y)
  } 
 environment( MyFunction ) 

 e3 <- new.env()
 e3$x <- 4
environment(MyFunction) <- e3
environment(MyFunction)
MyFunction()
```

Another illustration, finding values in evaluation, enclosing, and global environments
```{r}
MyFunction = function() 
{ 
     age = 22 
     FromLocal = function() { print( age + 1 ) } 
     FromGlobal = function() { print( age + 1 ) } 
     NoSearch =  function() { age = 11; print( age + 1 ) } 
     environment( FromGlobal ) = .GlobalEnv 
     FromLocal() 
     FromGlobal() 
     NoSearch() 
 } 
> MyFunction() 
```


## Packages and Environments

Each packagae actually has three associated environments, in ascending order of parentage: 

1. Package environemnt: contains exported objects, typcially functions, anlaogous to public classes in OOP
2. Namespace environment: contains all package objects, including hidden functions called by functions in the package environment. Analogous to private classes. 
3. Imports environemnt: contains dependencies from other packages. This usually contains only the other package's namespace and imports, not its package environemtn. Always enclosed by base, which ensures other packages don't mask base functions from the imports.

Alternatively, a Depends environemnt can be specifeid. If this is used, the _entire_ dependenecy package is loaded as if library() were called on it, and the dependency's three associated environemnts are attached to the search path,e nclosing the global environment. Like any namespaces on the search path, these can cause masking issues if anohter package has a function with the same name. It is better to use imports, to contain dependencie, since R will search a package's imports environment before resorting to the global search path.

Each environement is a susbet of the previous one. Pointers in each environment point to shared elements; it is perfectly possible for the same object to be bound in multiple environments. For example, the sd function's enclosing environemnt is namespace:stats, whether retrieved from the stats namespace or package environment. So when a package function is run, the enclosure created is always the namespace.

```{r}
statspackenv <- as.environment("package:stats")
sdFunc <- get("sd", envir = statspackenv)

environment(sdFunc)

statsnamespacenv <- environment(sdFunc)
sdFunc2 = get( "sd" , envir = statsnamespaceenv) 
environment( sdFunc2 ) 
```
Say the ggplot function calls another function, my_function. R first looks in the evaluation environment of ggplot, then the ggplot2 namespace, then imports, then namespace:base, then returns to the global environment, then works up the search list (where MyFUnction would be if it came with a package specified as a ggplot2 dependency).
Functions can be passed to each other only because they carry enclosing environments. This way, a passed function will behave predictably, no matter where it is invoked in the call stack. For the last time _the environment chain is not the same as the call stack_.  The environment chain is used for variable scoping, the call stack only in special cases.

# Environments

The most crucial point: R functions' enclosures (where the search path begins) are the environemnt where the function is defined, not the caller environemnt. This is called lexical scoping. Non-primitive functions (closures) are bound to enclosing environments (hence the name), which is why manufactured functions work: they have access to the variables in the parent function. If functions are both defined and called in the global environment, all is good. Problems arise when functions are defined within functions. constructor
Parent.farme fixes this. Because of lazy eval, parent.frame() returns the parent when it is evaluated (often in an eval call), not when it is passed as a function arg, so be careful.

By default, eval's EVALUATION environemnt is the caller environemnt (of the eval call), and its ENCLOSING environment is the caller environment (if env is a list or pairlist), otherwise the base environemnt (the namespace of base).

The global environemnt's parents are the sequence of loaded packages, in reverse order.
Here, y is looked up in the global environemnt, not inside f, so $f(3)=34$. 
```{r}
 y <- 10
 
 f <- function(x) {
        y <- 2
        y^2 + g(x) }
 
 g <- function(x) { 
         x*y
 }
 f(3)
```


In SE, for a function called in the global environemnt (equivalently, at the console), R finds the function defintion linked to the quoted name of the called function, thenn does the same for objects. Each value is substituted in turn. The search path starts at the global environemnt (the workspace), then proceeds through the namespaces,ending at base, which is why masking base functions is a bad idea.

The reason primitives break Magrittr pipes is that they don't evaluate lazily., sincne prmitives aren't closures. Closures have an enclosing environment (usually the caller env),allowing lookup of names there. Primitives lack this. The encolsing environemnt is the namespace where the function is defined (e.g., base), but global objects are still accessible. Primitives directly interface compiled machine code and thereforee contain no expressions or enviornments

Environments consist of frames mapping names to objects, and each has its own enclosrure - a parent environment that lies one step up the search path. Should a name not be found in a frame, the enclosure is searched next, all the way up the chain, to the empty environemnt that enclsoes base. ENvironments are NOT copied when assigned or passed to functions (i.e., are always modified in place), so don't assign multiple names to the same environment!

Once values in a function call are substituted, R repeats the process to When a function is run. It first creates an enclosing environemnt (coonfusingly called the function environemnt), by default where the function is defined. It then creates an evaluation environment by evaluating function parameters in the CALLING environemnt (not the enclosing environment).  It then fills this frame with function parameters, evaluated in the calling environemnt (or its parents). (Rememebr arg evaluation is lazy). 

Once a function and arguemtns are substituted intoa  call, the process repeats for expressions within the function body _before the function is actually run_. The evaluation environment for this stage is the one from which the function was called. Primitives are not closures becuase they interface machine code directly and lack R expreesions or environment references; they have no encolsing environment. This repeats  for every function and name in the function body until primitive functions are reached and machine code is run.
Once this process is complete, the evaluation enviornment to actually process the call is created, and the calling envrionment becomes the enclosure.


The the crucial point is that once parameters are evaluated in the calling enviornment and the function's evaluation environment is established, _the evaluation environment's parent is the enclosing environment where the function was defined_. In other words, the enviornment chain used to evaluate the function call differs from the one used to evaluate the function itself.


This is an example of masking. Running this function creates an evaluation envronemnt enclsoed by global, so the functions $w$ masks the global one.
```{r}
w <- "AD"
fun <- function() {
  w <- c("am", "I", "fun")
  rev(w)
}
fun()
```

This walks through the NSE used by with. List2envi isn't necessary here. The concept is simple: interpose an environment between the the function's evaluation environment and the usual enclosure (the global environment). Note that list2env's environemnts are enclosed by the global environment by default.
```{r}
L <- list(w=c("am", "I", "list"))
expr  <- quote(rev(w))   # capture expression
Lenv <- list2env(L)      # convert list to env
eval(expr, envir=Lenv) 
```
Names defined in parent environments are accesssible. Here the expression can access both L2env and its parent, Lenv.
```{r}
L2 <- list(rev=toupper)
L2env <- list2env(L2, parent=Lenv)
eval(expr, envir=L2env)
```


I think you know this. Rememebr, eval unquotes. Setting the calling environemnt as the enclosure is critical here. Parent.frame(), when called in a function bodym gives that function's calling environment
```{r}
with2 <- function(data, expr) {
  expr2 <- substitute(expr)
  eval(expr2, data, enclos=parent.frame())
}
with2(L, rev(w))
```
COnfusing terminology alert: parent.env returns to the enclosing environment, parent.frame to the _calling_ environment (parent of the evaluation environment).


## Customizing Environments

Problems arise becuase functions always create their own evaluation enviornments, but captured expressions refer to names in the calling environment, which is not necessarily the function's enclosing environemnt.

By default, eval's enclosing environemnt is the caller environemnt if the exercution environemnt (supplied by envir) is a list. Here, after the function variable expr2 is unquoted, eval looks for expr2 (contained in the unquoted expression) in the default enclosing environment of with2_bad. That value of expr2 masks the one defined in the global environment (which we wanted). The call ends up being rev(rev(expr2)). It ends up reversing the captured expression within with2_bad, not the expr2 defined in the global environment we intedned to substitute. By default, the eval call is evaluated with with2_bad as the enclosure. Setting the enclsoure to parent.frame() starts the environemnt chain _for eval_ in with2_bad's calling environment (the global environment), avoiding the collision. Otherwise, eval's enclosure is with2_bad itself.

"But eval's default enclosure if given a list for the envir arg is aslo parent.frame()," you complain. _Passed arguments are evaluated in the calling environment, while defualts are evaluated inside the function's evaluation environment_. So leaving the default parent.frame() in place ensures eval's enclosure is with2_bad

Parent.frame() gets the callinge nvironment of the function BODY (here the global enviornemnt), not that of the eval call. It forces eval to begin lookup in the global environemnt, not with2_bad.

The takeaway: be careful that function objects don't mask global ones!
```{r}
with2_bad <- function(data, expr) {
  expr2 <- substitute(expr)
  eval(expr2, data)
}
with2_bad(L, rev(w))
expr2 <- c("pathological", "I", "am")
with2_bad(L, rev(expr2))
```
A subtler error occurs here. Becasue with2_bad evaluates in its own environment, it looks for z in its enclosing environemnt - the global environment. So the z in friendly_fun gets bypassed.  This a danger of calling functions withitn functions. This is the opposite of the previous problem.

Critical point: _functions are enclosed by where they are defined, not the environemnt of the function that calls them._

```{r}
z <- c("Uh-oh!")
friendly_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2_bad(L, paste(c(z, w), collapse=' '))
}
friendly_fun(L)
```

Again, parent.frame() is the fix.

```{r}
friendlier_fun <- function(L) {
  z <- c('hello', 'friend', '!')
  with2(L, paste(c(z, w), collapse=' '))
}
friendlier_fun(L)
```

This code usually works because the mean_call expression is evaluated with thecalling environemnt of mean_by_grp as a parent - the global environment (Note how parent.frame() is called within mean_by_group, rather than passed as an argument to eval, peventing lazy evaluation. But it fails if another object masks mean. Normally namespaces (the usual enclosure of mean) prevent this, but not with manually constructed environemnts:
```{r}
mean_call <- function(expr) {
  call <- quote(mean(NULL))
  call[[2L]] <- expr
  call
}
mean_by_grp <- function(data, expr, grp) {
  call_env <- parent.frame()
  grp <- eval(substitute(grp), data, enclos=call_env)
  data <- split(data, grp)
  expr <- mean_call(substitute(expr))
  res <- setNames(numeric(length(data)), names(data))

  for(i in seq_along(data)) {
    res[[i]] <- eval(expr, data[[i]], enclos=call_env)
  }
  res
}
```


```{r}
mean <- function(...) stop("Boom")
try(mean_by_grp(iris, Sepal.Length / Sepal.Width, Species))
```
This could be fixed by susbtituting mean directly into the call because the base namespcase (where R looks for the name mean) encloses mean_call's parent environemnt (above the chain of other names[aces, where alternate definitions of mean would still mask the one in base) ,  the faulty global definition (otherwise reached by starting in caller_env) is bypassed.
```{r}
mean_call <- function(expr) {
  call <- quote(NULL(NULL))  # call template
  call[[1L]] <- mean         # actual function object
  call[[2L]] <- expr
  call
}
```



# Quosures

bquote is the base quasiquoting funciton. It unquoutes anything inside a special .() syntax. Here it inlines a caputred expression into a call to mean:

```{r}
a <- 1
b <- 2
mean_call2 <- function(expr) {
  bquote(mean(.(substitute(expr))))
}
mean_call2(a + b) %>% eval()
```
The subsitute call gets evaluated, though not the expression itself.

Extra note: local() will define a temporary top-level environemnt for testing expressions. This masks the global a:

```{r}
a <- 1
num <- 2
local({
  a <- 100
  a + num
})
```


I think you know how quosures work:
```{r}
```


```{r}
q <- quo(a + b)
eval_tidy(q)

```
Capturing environments is quite useful. Base quote evals in the wrong place here:
```{r}
a <- 1
lang <- local({
  a <- 100
  list(
    base=quote(a + 1),
    rlang=quo(a + 1)
  )
})

eval(lang[["base"]])
```
Compare base and rlang implementations of a mean quoting function. The rlang version exploits the ability of quosures to handle !!.
```{r}
mean_in_data <- function(data, expr) {
  expr <- substitute(expr)           # capture user expression
  expr <- bquote(mean(.(expr)))      # wrap it in `mean`
  eval(expr, data, parent.frame())
}
```

```{r}
mean_in_data_rl <- function(data, expr) {
  quosure <- enquo(expr)           # capture user expression
  quosure <- quo(mean(!!quosure))  # wrap it in `mean`
  eval_tidy(quosure, data)
}
```

This could also be done with {{}}, which quoutes the arg, unquotes, then quotes it in one step:

```{r}
mean_in_data_rl2 <- function(data, expr) {
  quosure <- quo(mean({{expr}}))     # notice: no enquo
  eval_tidy(quosure, data)
  mtcars %>% group_by(!!quosure)
}

mean_in_data_rl2(mtcars, cyl)
```

Time to stress-test. The base version here fails because the parent.frame() call in mean_data broke the link to the base namespace on the search path, finding the mean defined in the caller environemment (the local environemnt) allowing the local mean to mask it. The rlang version takes a quousre, correctly catching the enclosing enviornment of base::mean.

In base, the problem is insurmoutnable: we want mean evaluated in the enclosing environemnt and the expression evaluated in the data  passed from caller environment. Only on environemnt chain can exist at once, so this is impossible.
```{r}
l.per.cubic.i <- 1                      # decoy
local({
  mean <- function(x) -base::mean(x)    # decoy
  l.per.cubic.i <- 2.54^3 / 1000
  list(
    base=mean_in_data(mtcars, disp * l.per.cubic.i),
    rlang=mean_in_data_rl(mtcars, disp * l.per.cubic.i)
  )
})
```

## How Quosures Work

Qusoures are actually formulas, which are expressions that quote themselves and capture the evaluation environment where they were created. 
```{r}
unclass(quo(a + b))

```

Normally evaluting formulas is poitnless: the tilde quotes the whole expression and is preserved, so evaluating just quotes it again!

```{r}
eval(~((a+b)))
```
The implementation creates an environemnt where ~ is a function that evaluates its input in the formula call's environment. The ~ function quotes itws own call (with sys.call()), which is equal to the captured formula, then evaluates the formula expression (with the tilda stripped away), in the formula's environemnt. Binding ~ to a funciton and negative susbetting the first element of the captured call allows the tilda to be stripped away.

```{r}
eval_tidyish <- function(expr) {
  env <- new.env(parent=parent.frame())
  env[['~']] <- function(...) {# replace `~` with our version
    call <- sys.call()
    env <- environment(call)   # recover formula env from call
    eval(call[[2]], env)
  }
  eval(expr, env)
}


```

```{r}
a <- 10
q1 <- local({
  a <- 1/2
  ~ a * 2
})
q1
eval_tidyish(q1)

```
But you still can't inline expressions within the formula's environemnt. Here the a in the global environment masks the last term:
```{r}
q2 <- local({
  a <- 1/8
  ~ a + 1/8
})
bquote(.(q1) / .(q2))
eval_tidyish(bquote(.(q1) / .(q2) + a))
```


##

It's possible to capture and unquote an environemnt. This will obviously fail if called from within a function:
```{r}
quote_w <- function(x) {
  caller <- parent.frame()           # must be outside `bquote`
  bquote(with(.(caller), .(substitute(x))))
}
quote_w(a+1) %>% 
  eval
```
Here, capturing the local a is the intended behavior. These both work:
```{r}
a <- 10
q1 <- local({
  a <- 1/2
  quote_w(a * 2)
})
q1
eval(q1)

q2 <- local({
  a <- 1/8
  quote_w(a + 1/8)
})
(q3 <- bquote(.(q1) / .(q2)))
eval(q2)
```
This approach captures the expression (importatnly, in the .() form for terms to unquote) and inlines it into ane xpression using bquote (note the uqnuoting of the function name itself). This substitutes the terms to quasiquote with their values in the caller environement. This is then evaluated in the calling environement. Bquote is used again to inline _this_ into a call to with, evalauted in the caller environment.

```{r}

a <- b <- 2
expr <- local({
  a <- 1
  bquote_w(a + .(b))
})
expr
eval(expr)

bquote_w <- function(x) {
  caller <- parent.frame()
  expr <- eval(bquote(.(bquote)(.(substitute(x)))), caller)
  bquote(with(.(caller), .(expr)))
}
```


This nightmare is a substiute implementation that captures the calling environment like enquo does.

It captures the caller enviornment and that environment's calling environemnt. It inlines the expression x into a substitute call evaluated in the caller environemnt, then evaluates it, extracting the passed expression. This is then inlined into a bquote call that is evaluated in the caller's parent, substtiuting the quasiquoted value. the completed expression is evaluated in the caller's parent.

```{r}
substitute_w <- function(x) {
  caller <- parent.frame()
  caller2 <- sys.frame(sys.parent(2))   # see appendix for explanation
  expr <- eval(bquote(substitute(.(substitute(x)),.(caller))))
  expr <- eval(bquote(.(bquote)(.(expr))), caller2)
  bquote(with(.(caller2), .(expr)))
}

f <- substitute_w
a <- b <- 2
f <- function(x) substitute_w(x)
expr <- local({
  a <- 1
  f(a + .(b))
})
expr
```

Here is a function that creates a data mask:

```{r}
mask <- function(expr, data) {
  if(is.language(expr) && length(expr) > 1L) {
    # modify `with` expressions that contain a live environment
    if(expr[[1L]] == as.name('with') && is.environment(expr[[2L]])) {
      expr[[2L]] <- list2env(data, parent=expr[[2L]])
    }
    # recurse on each sub-expression
    expr[2L:length(expr)] <- lapply(expr[2L:length(expr)], mask, data)
  }
  expr
}
```

