

## 1/11/21

qnrom and pnorm are inverses such that qnorm(.975) = 1.96 and pnorm(1.96)=.975

```{r}
qnorm(.975)
pnorm(1.96)
```
pmatch matchs a single vector against another; unlike match, it ignores inccomensurate lengths and counts a match wherever the vectors intersect.

```{r}
pmatch(c("cyl", "disp", "mpg"), colnames(mtcars))
```

You can set an xlim or ylim arg element to NA to represent the max or min of the corresponding data!


For each index of the LHS vector, match gives the index of the first match in the RHS, NA if no match. So the output always has the input's length.
```{r}
match(c("a", "b", "d", "s", "s", "7"), letters)
```

Subsitute has an undocumentedqay of acting like neexprs:

```{r}
f <- function(...) as.list(substitute(...()))
f(x = 1, y = 10 * z)
```

Be careful: Length-0 vectors, like NA's, defeat logical comparisons and pollute all they contact. Mitigate this using double Boolean operators

```{r}

v <- 5
v | numeric(0)
#but
v > 3 || numeric(0)
```
There's a base replace function!
```{r}
replace(mtcars$cyl, which(mtcars$cyl ==6), 3)
```

seq_date does hwat you'd expect

Unnest_longer is so useful. From someone better than me on Reddit:
```{r}
tibble(
    date_1 = ymd("2018-11-15"),
    date_2 = ymd("2021-01-15")
) %>%
    mutate(years = map2(date_1, date_2, ~ year(.x):year(.y))) %>%
    unnest_longer(col = years)
```

There's a vectorized product?! And length!
```{r}
prod(1:10)
lengths(mtcars)
```
You can use intersect with reduce

Duplicated function checks for jsut that
No reason you can't do this:

```{r}
rep(list(c(0,1)), 5)
```


## 1/17/21

Repeat indices to stretch matrixes or dataframes
```{r}
mtcars[, rep(1:ncol(mtcars), each = 3)]
```

## 1/18/21

Ensym will convert strings to symbols but also handle symbols! Enquo doesn't, of course.

rainbow takes an integer arg and reurns that many unique colors:

```{r}
rainbow(999)
```

Use show.legend = FALSE to hid specific aesthetics from the legend and use override.aes to manually specify which appear.

xtfrm gives a numeric vector that sorts in x's order

```{r}
xtfrm(letters)
```

## 1/19/21

Time to finally learn mapply. This applies multiple sets of vector elements in parallel. So:

```{r}
mapply(rep, 1:7, 7:1)

```

feeds rep the x and each arguments.

Vectorize functions as you go:

```{r}
mapply(rnorm, 1:5, 3)
```


## 2/18/21

HERE is how you pivot anscombe. 
```{r}
anscombe %>% pivot_longer(everything(),, names_to = c(".value", ".value", "num"), names_pattern = "(?:(x)|(y))(\\d)")
```

