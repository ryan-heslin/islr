


# Logarithms

## Intuition

Most basically, the log gives the number of zeroes in a number reduced to the next-lowest power of 10, with zeroes to the right of the decimal point counted negatively. Thus:

\[
log(.1)=-1
log(1)=0
log(10)=1
log(100)=2
\]

etc.

Logs express relationships that increase by a constant multiple, hence log scales showing multiplicative units


```{r}
p <- tibble(x = 1:1000, y = 10^(1:1000/100)) %>% 
  ggplot(aes(x = x, y =y))+
  geom_point() +
  geom_line() 
  
p
p +scale_y_log10()
```

Roots, logartihms, and exponenets express three aspects of the same rationship: The base, the exponent, and the resut. The exponent form omits the result, the root the base, the logarithm the exponenet. Each operation completes the missing corner of the triangle. 

\[
10^3=1000
\sqrt[3]{1000}=10\\
log_{10}1000=3\]

So the inverse of a known base to an unkown exponent is the log, while an unknown base to a known exponent is the root

\[10^x\rightarrow\log_{10}y\\
x^{10}\leftarrow\sqrt[10]{y}\]

A logarithm "wants" to be an exponent, a root to be a base.

## Examples

Additive property: This follows because multiplied numbers rasied to exponents adds the exponents

\[\log{ab}=\log{a}+\log{b}\\\]
\[\log{1000}\cdot{x}=3 + \log(x)\]


Multiplicative property: the log of a base raised to an exponent equals the exponent times the log of the base. This follows from the "zero counting" property of the log - each extra multiplication indicate dby adding 1 to the base adds another log unit. We're multiplying the zeroes addes by the exponent to those that exist in the base.
\[(log(x^n)=n\log{x}\\
\log{10^3}= 3(1)\]

Symmetrically, $(10^x)^n =10^{nx}$. In the log form, the log represents the part inside the parentehses, the n the outer exponenet.

"Base-swapping." The log of a number at a base equals the inverse of the log with the base and number swapped. 
\[\log_ab=\frac{1}{\log_ba}\]

\[\log_{10}(1000)=3\\
\log_{1000}10 = \frac{1}{3}\]

This follows from the fact that inversing an exponent transforms the result into the base: if the result is bigger than the base, the inverse is a fraction so it can be shrunk down. For example:
\[b^x=a\\
b=a^\frac{1}{x}\]

Because logs are multiplicative units of growth, logs do not grow linearly between different whole-number units; i.e., $log(\frac{a^n+a^{n+1}}{2} != \frac{\log{a^{n+1}}-loga^n}{2}$.

This property is notroiously confusing. This expression, for instance, is a little above 4, an even log unit.
\[\log(10000+100)\rightarrow10^x=10100\]

There is no consistent rule for $\log(a+b)$.
## Miscellany

Logs of 0 are of course undefined because multiplicative units of 0 do not yield anything. In addition, $a^0$ is non-reversible-it maps all numbers to 1, with no way of recovering the base from teh resulting exponent. 

Again: logs are units of powers of the base (e.g., Richter scale having base 32 raised to the scale number).

Notice that $2^10 = 1024$. This means $2^{10} \approx 10^3$. So $2^{10}=(2^x)^3=2^{3x}$. Thus $3x=10$, so it is also true that $\log_{10}(2)\approx0.3$

This pattern of log base 2 being aout a third of log base 10 holds true for higher numebrs as well, e.g. \[\log_2(1000000)\approx20\\
\log_{10}(1000000)=6\]

In general, logs of the same number with different bases are scales of each other.


This last property is subtle:
\[\log_c(b)\cdot\log_b(a)=\log_c(a)\]

The $b$'s have disappeared. The expression expresses a in multiplicative units of b and c in multiplicative units of b. To get $a$ in multiplicative units of $c$, we multiply the results of the two logs.

For illustration, note that:
\[\log_{10}(100)\cdot\log_{100}(1000000)=\log_{10}1000000\\
2\times3=6\]

This property follows from the multiplicative nature of exponents: 

\[c^y=b\\
b^x=a\\
c^{xy}=a\]

This is really something like $(10^2)^3$. We extract the multiplicative units of the second base contained in the first and combine the results.

## Change of Base

\[\log_b(a)=\frac{\log_c(a)}{\log_c(b)}\]

\[\log_{100}(1000000)=\frac{\log_{10}(1000000)}{\log_{10}(100)}\]

Division really indicates the number of groups of the divisor contained by the dividend. But logs themselves express division in multiplicative, not additive, units. Like the previsou property, the base of one log is decomposed into an input of a log of another base.

Recall that logs of different numbers of the same base are scales of each other. _The base is arbitrary_; what matters is the ratio of multiplicative units of the base in $x$ to 2. Conversely, logs of the same number with different bases have a scalar relationship as well, e.g., $\log_2(x)\approx.3\log_{10}(x)$.

\[\log_2(x)=\frac{\log_{10}(x)}{\log_{10}(2)}\]


```{r}
coordinates <- "F47
W2
S5
R180
R90
N3
F44
W1
N3
F77
S5
L270
F39
N3
L90
F83
W4
R270
E2
F98
N3
R180
N3
F54
N1
W4
R90
N1
L90
S2
E4
N4
W2
R90
F42
W3
S4
L90
E5
F6
R180
N4
E5
R180
E3
N3
F27
L90
S4
L180
E4
F52
E2
N1
R90
E3
S4
F76
R270
W2
R90
S2
R90
F79
S1
L180
F81
E3
F79
L90
S3
L180
F52
S5
L90
N4
W2
F65
N2
W1
R90
F25
W4
L90
S2
R90
N1
F13
W1
N1
F71
N3
L90
W4
R90
F91
W5
N3
W3
S3
F58
W4
N5
W3
F42
S4
E5
N3
F14
L180
E5
L270
F55
N3
R90
R90
S4
F55
W2
N1
W5
R180
F8
E3
L270
N2
F12
N2
R90
W1
R90
W2
L90
S2
F75
L90
S4
E3
F82
L90
L90
F42
N4
E5
F67
R90
E3
F64
E4
R90
F42
S4
F85
W5
S5
R90
F35
R270
W5
F67
R90
S5
R180
S1
F13
N4
W5
S2
F31
L90
E2
F39
R90
F3
W4
N2
F14
E2
F80
L180
F52
N3
E2
F98
W2
F29
R180
E2
L90
W4
N3
W1
S2
W1
N5
F6
E5
E1
W2
R90
S3
F92
L90
E5
F55
L90
S3
R90
S2
L90
N1
E5
F50
L90
N4
F9
L90
N4
L90
R90
R180
E3
F57
L90
S5
R180
S3
E4
F41
W5
N4
W2
N2
R90
S2
W1
F83
R180
W1
R90
W1
F17
F20
S1
E5
F13
N5
F8
F81
E2
S4
F7
W2
F86
N2
L90
N5
L180
E2
R90
E3
S3
N4
W2
F64
L90
F81
L90
E4
F1
E3
L90
W5
L90
N3
F28
F3
F100
E5
N5
F32
R90
W1
R90
S3
W1
W5
N3
F27
R90
W2
R180
W3
W2
N2
E2
S1
R90
W3
F51
E5
N4
W3
S5
R90
F91
S3
W1
S4
R270
N5
W4
F94
R90
N4
L90
N4
R90
F35
E3
F6
S4
F98
E2
L180
W4
N5
F42
S3
W3
N1
R90
S5
E3
S3
F47
S1
F19
W5
R90
F17
R90
N4
R90
F57
E2
F73
W3
F52
F98
R90
N1
F88
N2
E4
S4
R90
E2
R90
N5
F75
L180
F61
E2
S4
N4
W1
N3
E2
N3
F44
E3
L180
N4
F16
E2
S1
L180
R90
W5
F65
S5
F31
E3
L90
N5
E4
S5
E4
S4
R90
F70
R90
W4
L90
N3
W1
L90
S3
L90
F91
L180
S3
R90
N5
L90
S5
W2
F18
E3
F19
N1
F70
R90
E3
S4
F46
N2
S3
W2
S4
F7
L90
E4
R90
F78
S1
F4
L90
W3
F78
E5
L270
F86
E3
F82
L90
F32
R90
E4
L90
E4
L90
E3
F63
N4
E4
L90
F70
R180
F30
R180
F40
N5
R90
W4
F16
L180
S1
W1
R180
F12
W3
L90
F93
S2
L270
F36
L90
W2
N2
F3
W2
L180
L90
F24
S1
W5
R90
E4
L180
E1
S1
L90
F94
L90
F55
N2
E5
F33
E3
L90
N2
L90
S2
R90
F67
W4
F79
E1
E5
F5
S5
R180
F5
E2
E5
N4
W5
N4
W5
E2
L90
F2
L90
N4
E3
N3
R90
F92
N5
F83
L90
F85
R90
W5
S2
L90
E1
F34
E3
L180
W3
R90
F29
W4
L90
F34
W1
S4
E2
S1
W2
W5
L90
E5
N4
R180
N2
W5
R90
F42
W3
N2
L90
F79
W2
F16
N5
E3
F52
F55
L90
F42
L90
W4
S2
E5
L90
S4
F34
N5
N1
L180
L90
E2
L90
W3
L90
F16
E2
F96
N3
E1
F34
R180
S2
F17
W1
L270
F7
W2
N1
F33
N4
F2
N5
R180
F10
W3
L90
S3
E2
S1
F85
N2
F1
R180
F10
N4
W3
S2
R180
N4
W3
S2
S4
L90
E5
N1
F34
S4
W2
W5
F62
S5
E5
S4
F100
L90
W2
F20
S2
E1
R180
F88
N5
F85
N2
R90
N1
E5
F83
R90
W1
R90
E1
F11
E3
F54
N5
L180
F54
R90
S2
E3
L90
E3
N5
R90
W1
S5
R270
F91
E3
F52
W1
F36
W1
N5
F53
E1
R180
N3
F12
L90
S5
F99
S1
R90
S4
R90
S1
W1
N2
L270
W5
F78
S2
R90
F37
W5
R90
E3
S2
E4
L90
S3
W4
F83
L180
S3
R90
F57
W1
S1
L180
W2
N1
R180
N1
L180
W3
S3
R180
E4
F77
N5
S3
W1
N4
F4
N5
F64
W1
R90
N2
W5
L90
N3
L90
F8
L90
F3
S5
F95
R90
W2
F15
L270
F49
R180
S3
F15
N5
L180
S2
F71
S5
F56
W1
F22
F90
E5
F68
N4
R180
N5
E4
F52
E5
L90
E3
F69
W4
S3
L90
N4
R90
F19"  %>% str_split(., "\n") %>% unlist() %>% {.[-771]}
taxicab_dist <- function(coordinates, orient = 90){
  xy <- c(10,1) %>% set_names(c("x", "y"))
  total <- c(0,0)
  angle <- 0
  ops <- tibble(cond = exprs(orient ==0, orient>0 & orient<90, orient ==90, orient>90 & orient< 180, orient ==180, orient> 180 &orient <270, orient==270, orient > 270), x = exprs(0, sin(orient) *dist, dist, cos(orient) *dist, 0, -sin(orient)*dist, -dist, -cos(orient) *dist), y = exprs(dist, cos(orient)*dist, 0, -sin(orient)*dist, -dist,  -cos(orient*dist), 0, sin(orient*dist)))
  #browser()
  for(el in coordinates){
    
    init <- substr(el,1,1)
    if(init %in% c("R", "L")){
      angle <- (as.numeric(str_extract(el, "\\d+"))  *ifelse(init == "R", 1, -1)) %% 360
      
      # Seqeuntial 90-degree rotations
      for(i in seq(1, angle %/% 90)){
        prev <- xy
        xy[1] <- prev[2]
        xy[2] <- -prev[1]
      }
    }
    else if(init == "F"){
      reps <- as.numeric(str_extract(el, "\\d+"))
      total <- total + xy*reps
      # angle <- orient %% 90
      # 
      # row <- which(map_lgl(ops$cond, eval, env =list(orient = orient)))
      # print(row)
      # x <- x +eval(ops$x[[row]], list(dist = dist))
      # y <- y +eval(ops$y[[row]], list(dist = dist))
    }else{
      dist <- as.numeric(str_extract(el, "\\d+"))
      
      if(init %in% c("E", "W")){
        xy[1] <- xy[1] + dist *ifelse(substr(el,1,1)=="E", 1, -1)
      }else{
        xy[2] <- xy[2] + dist *ifelse(substr(el,1,1)=="N", 1, -1)
      }
    }  
  }
  sum(abs(total))
}

test <- c("F10", "N3", "F7", "R90", "F11")
taxicab_dist(coordinates = coordinates)
```


```{r}
```


```{r}
```

